<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Maps!</title>
  <style>
    button {
      font-size: 50px;
      margin:10px;
    }
  </style>
</head>
<body>

<script>

  /*
    The Map object holds key-value pairs and remembers the original insertion
    order of the keys. Any value (both objects and primitive values) may be
    used as either a key or a value.

    And just like the garbage collection of a WeakSet, a WeakMap is pretty
    much exactly the same.

    A WeakMap doesn't have a size, and you can never tell how many elements
    are in it. A WeakMap is not enumerable, which means you cannot loop over
    it. The items inside of a WeakMap, if they no longer exist anywhere else
    in your application, they will get garbage collected and they'll be
    removed from your WeakMap.
  */

  // Example showing the difference between a regular Map and a WeakMap.
  // 2 objects
  let dog1 = { name: "Rubble" };
  let dog2 = { name: "Chase" };

  // 2 maps
  const strong = new Map();
  const weak = new WeakMap();

  // add to each map
  strong.set(dog1, "Rubble on the double!");
  weak.set(dog2, "Chase is on the case!");

  // strong - Map(1) {{…} => "Rubble on the double!"}
  // weak - WeakMap {{…} => "Chase is on the case!"}

  // strong.size - 1
  // weak.size - undefined

  // delete them
  dog1 = null;
  dog2 = null;

  console.log(strong); // Map(1) {{…} => "Rubble on the double!"}
  console.log(weak); // WeakMap {}

  // The `strong` map still holds on to the object that no longer exists
  // which is a memory leak because we don't have any way to reference it.

  // The WeakMap (`weak`) has totally clean it up, garbage collection has
  // taken place. No reference to the object exists. A use case of why you
  // might use a WeakMap over a Map.


</script>
</body>
</html>